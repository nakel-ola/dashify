export type DataType = {
  name: string;
  dataType:
    | 'int2'
    | 'int4'
    | 'int8'
    | 'float4'
    | 'float8'
    | 'numeric'
    | 'json'
    | 'jsonb'
    | 'text'
    | 'varchar'
    | 'uuid'
    | 'date'
    | 'time'
    | 'timetz'
    | 'timestamp'
    | 'timestamptz'
    | 'bool';
  isPrimary: boolean;
  isNullable: boolean;
  isUnique: boolean;
  isArray: boolean;
  isIdentify: boolean;
  defaultValue?: string | null;
  references?: {
    onUpdate?: 'Cascade' | 'Restrict' | null;
    onDelete?: 'Cascade' | 'Restrict' | 'Set default' | 'Set NULL' | null;
    collectionName: string;
    fieldName: string;
  };
};

const dataType: Record<DataType['dataType'], string> = {
  int2: 'SMALLINT',
  int4: 'INTEGER',
  int8: 'BIGINT',
  numeric: 'NUMERIC',
  float4: 'FLOAT4',
  float8: 'FLOAT8',
  json: 'JSON',
  jsonb: 'JSONB',
  text: 'TEXT',
  varchar: 'VARCHAR(255)',
  uuid: 'UUID',
  date: 'DATE',
  time: 'TIME',
  timetz: 'TIMETZ',
  timestamp: 'TIMESTAMP',
  timestamptz: 'TIMESTAMPTZ',
  bool: 'BOOL',
};

type InsetType = {
  names: string[];
  values: (string | number)[][];
};

type AlterModifyType = {
  operations: (
    | 'Rename'
    | 'Type'
    | 'Add Default'
    | 'Remove Default'
    | 'Add Not null'
    | 'Remove Not null'
    | 'FOREIGN'
  )[];
  name: string;
  newName?: string;
  dataType?: DataType['dataType'];
  defaultValue?: string | number;
  references?: {
    onUpdate?: 'Cascade' | 'Restrict' | null;
    onDelete?: 'Cascade' | 'Restrict' | 'Set default' | 'Set NULL' | null;
    collectionName: string;
    fieldName: string;
  };
};

type ForeignKeyType = Pick<DataType, 'references' | 'name'>;

export class PostgresQueryGenerator {
  constructor() {}

  public createTable(tableName: string, items: DataType[]) {
    let results: string[] = [];

    const primaries = items.filter((item) => item.isPrimary === true);
    const foreigns = items.filter((item) => item.references);

    for (let i = 0; i < items.length; i++) {
      const item = items[i];

      const column = this.createColumn(item, primaries.length === 1);

      results.push(column);
    }

    if (primaries.length > 1) {
      results.push(
        `PRIMARY KEY (${primaries.map((primary) => primary.name).join(', ')})`,
      );
    }

    if (foreigns.length > 0) {
      results = [...results, ...this.formatForeigns(foreigns)];
    }

    const query = `CREATE TABLE IF NOT EXISTS ${tableName} (${
      results.length > 0
        ? results.join(', ')
        : ['id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY'].join(', ')
    });`;

    return query;
  }

  public alterTable(tableName: string, type: 'add' | 'drop', item: DataType) {
    const column = this.createColumn(item, true);

    let query = `ALTER TABLE ${tableName}`;

    if (type === 'add') query += ` ADD COLUMN  ${column}`;
    if (type === 'drop') query += ` DROP COLUMN ${item.name}`;

    return query;
  }

  public alterModify(tableName: string, item: AlterModifyType) {
    const query = `ALTER TABLE ${tableName}`;

    const results: string[] = [];

    for (let i = 0; i < item.operations.length; i++) {
      const operation = item.operations[i];

      if (operation === 'Rename') {
        results.push(`${query} 
        RENAME COLUMN ${item.name} TO ${item.newName};`);
      }

      if (operation === 'Type') {
        results.push(`${query} 
        ALTER COLUMN ${item.name} TYPE ${dataType[item.dataType]};`);
      }

      if (operation === 'Add Default') {
        results.push(`${query}
        ALTER COLUMN ${item.name} SET DEFAULT ${item.defaultValue};`);
      }

      if (operation === 'Remove Default') {
        results.push(`${query}
        ALTER COLUMN ${item.name} DROP DEFAULT;`);
      }

      if (operation === 'Add Not null') {
        results.push(`${query}
        ALTER COLUMN ${item.name} SET NOT NULL;`);
      }

      if (operation === 'Remove Not null') {
        results.push(`${query}
        ALTER COLUMN ${item.name} DROP NOT NULL;`);
      }

      if (operation === 'FOREIGN') {
        const foreign = this.formatForeignKey({
          references: item.references,
          name: item.name,
        });
        results.push(`${query}
        ADD ${foreign}`);
      }
    }

    return results;
  }

  public insertIntoTable(tableName: string, data: InsetType) {
    const columnsName = data.names;

    const columnsValues = data.values.map((value) => `(${value.join(', ')})`);

    const query = `INSERT INTO ${tableName} (${columnsName.join(', ')})
    VALUES ${columnsValues.join(', ')}`;

    return query;
  }

  public dropTable(tableName: string) {
    return `DROP TABLE ${tableName};`;
  }

  private createColumn(item: DataType, singlePrimary: boolean) {
    let column = `${item.name} ${dataType[item.dataType]}`;

    if (item.isArray) column += '[]';

    if (item.isIdentify) column += ' GENERATED BY DEFAULT AS IDENTITY';

    if (item.isPrimary && singlePrimary) column += ' PRIMARY KEY';

    if (item.isUnique) column += ' UNIQUE';

    if (item.defaultValue !== null && item.defaultValue !== undefined)
      column += ` DEFAULT ${this.formatDefaultValue(item.defaultValue)}`;

    if (!item.isNullable) column += ' NOT NULL';

    return column;
  }

  private formatDefaultValue(value: string | null) {
    if (value === 'now()') return 'CURRENT_TIME';
    if (value === "(now() at time zone 'utc)")
      return "(CURRENT_TIMESTAMP AT TIME ZONE 'UTC')::TIME";
    if (value === 'gen_random_uuid()') return 'gen_random_uuid()';

    if (value === '') return `""`;

    if (!isNaN(value as any)) return Number(value);

    return `"${value}"`;
  }

  private formatForeigns(items: DataType[]) {
    const results: string[] = [];
    for (let i = 0; i < items.length; i++) {
      const item = items[i];

      const references = item.references;

      const constraintName = 'fk_' + references?.collectionName;
      let foreign = `CONSTRAINT ${constraintName}
        FOREIGN KEY (${item.name})
        REFERENCES ${references?.collectionName} (${item.references?.fieldName})
      `;

      if (references?.onUpdate) {
        foreign += `ON UPDATE ${references?.onUpdate.toUpperCase()}\n`;
      }
      if (references?.onDelete) {
        foreign += `    ON DELETE ${references?.onDelete.toUpperCase()}`;
      }

      results.push(foreign);
    }

    return results;
  }

  private formatForeignKey(item: ForeignKeyType) {
    const references = item.references;

    const constraintName = 'fk_' + references?.collectionName;
    let foreign = `CONSTRAINT ${constraintName}
        FOREIGN KEY (${item.name})
        REFERENCES ${references?.collectionName} (${item.references?.fieldName})
      `;

    if (references?.onUpdate) {
      foreign += `ON UPDATE ${references?.onUpdate.toUpperCase()}\n`;
    }
    if (references?.onDelete) {
      foreign += `    ON DELETE ${references?.onDelete.toUpperCase()}`;
    }

    return foreign;
  }
}
