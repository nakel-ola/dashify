export const getMongodbArrayType = (arr: any[]): any[] => {
  if (arr.length === 0) return [];

  const sampleValue = arr[0];
  let arrayType: any = typeof sampleValue;

  if (sampleValue === null) {
    arrayType = [];
  } else if (arrayType === 'object' && sampleValue instanceof Date) {
    arrayType = ['Date'];
  } else if (arrayType === 'object') {
    const objectType = getMongodbObjectFieldType(sampleValue);
    arrayType = objectType;
  }

  return arrayType;
};

export const getMongodbObjectFieldType = (obj: object) => {
  const fieldTypes = [];

  for (const key in obj) {
    if (key === '__v') continue;

    fieldTypes.push({
      name: key,
      type: key === '_id' ? 'string' : typeof obj[key],
    });
  }

  return fieldTypes;
};

export function getDataTypeGroup(dataType: string): string | null {
  const arrayTypes = [
    'int[]',
    'text[]',
    'varchar[]',
    'numeric[]',
    'json[]',
    'jsonb[]',
    'array',
  ];
  const stringTypes = [
    'char',
    'varchar',
    'text',
    'citext',
    'character varying',
    'character',
  ];
  const numberTypes = [
    'smallint',
    'integer',
    'bigint',
    'decimal',
    'numeric',
    'real',
    'double precision',
    'serial',
    'bigserial',
    'smallserial',
  ];
  const objectTypes = [
    'json',
    'jsonb',
    'hstore',
    'tsvector',
    'tsquery',
    'uuid',
    'point',
    'line',
    'lseg',
    'box',
    'path',
    'polygon',
    'circle',
  ];
  const timestampTypes = ['timestamp with time zone'];

  if (arrayTypes.includes(dataType.toLowerCase())) {
    return 'array';
  } else if (stringTypes.includes(dataType.toLowerCase())) {
    return 'string';
  } else if (numberTypes.includes(dataType.toLowerCase())) {
    return 'number';
  } else if (objectTypes.includes(dataType.toLowerCase())) {
    return 'object';
  } else if (timestampTypes.includes(dataType.toLowerCase())) {
    return 'timestampz';
  } else {
    return dataType;
  }
}

export function categorizeMySQLDataType(dataType: string, columnType: string) {
  const stringTypes = ['char', 'varchar', 'text', 'blob'];
  const numberTypes = ['tinyint', 'smallint', 'int', 'bigint'];
  const enumTypes = ['enum', 'set'];
  const arrayTypes = ['json', 'array'];
  const objTypes = ['json'];
  const datetimeTypes = ['datetime'];
  const timestampTypes = ['timestamp with time zone'];

  if (stringTypes.some((type) => dataType.startsWith(type))) {
    return { type: 'string' };
  } else if (numberTypes.includes(dataType)) {
    return { type: 'number' };
  } else if (enumTypes.some((type) => dataType.startsWith(type))) {
    const enumValues =
      columnType
        .match(/\((.*?)\)/)?.[1]
        ?.replaceAll("'", '')
        ?.split(',') || [];

    return {
      type: 'enum',
      enumValues,
    };
  } else if (arrayTypes.includes(dataType)) {
    return { type: 'array' };
  } else if (objTypes.includes(dataType)) {
    return { type: 'object' };
  } else if (datetimeTypes.some((type) => dataType.startsWith(type))) {
    return { type: 'datetime' };
  } else if (timestampTypes.some((type) => dataType.startsWith(type))) {
    return { type: 'timestampz' };
  } else {
    return { type: dataType };
  }
}

type DataType = {
  name: string;
  dataType:
    | 'int2'
    | 'int4'
    | 'int8'
    | 'float4'
    | 'float8'
    | 'numeric'
    | 'json'
    | 'jsonb'
    | 'text'
    | 'varchar'
    | 'uuid'
    | 'date'
    | 'time'
    | 'timetz'
    | 'timestamp'
    | 'timestamptz'
    | 'bool';
  isPrimary: boolean;
  isNullable: boolean;
  isUnique: boolean;
  isArray: boolean;
  isIdentify: boolean;
  defaultValue?: string;
};

export const formatPostgresDataType = (items: DataType[]) => {
  const results: string[] = [];

  const primaries = items.filter((item) => item.isPrimary === true);

  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    let column = `${item.name} ${dataType[item.dataType]}`;

    if (item.isArray) column += '[]';

    if (item.isIdentify) column += 'GENERATED BY DEFAULT AS IDENTITY';

    if (item.isPrimary && primaries.length === 1) column += ' PRIMARY KEY';

    if (!item.isNullable) column += ' NOT NULL';
    if (item.isUnique) column += ' UNIQUE';

    if (item.defaultValue) column += ` DEFAULT ${item.defaultValue}`;

    results.push(column);
  }

  if (primaries.length > 1) {
    results.push(
      `PRIMARY KEY (${primaries.map((primary) => primary.name).join(', ')})`,
    );
  }
};

const dataType: Record<DataType['dataType'], string> = {
  int2: 'SERIAL',
  int4: 'SERIAL',
  int8: 'BIGSERIAL',
  numeric: 'NUMERIC',
  float4: 'FLOAT4',
  float8: 'FLOAT8',
  json: 'JSON',
  jsonb: 'JSONB',
  text: 'TEXT',
  varchar: 'VARCHAR(255)',
  uuid: 'UUID',
  date: 'DATE',
  time: 'TIME',
  timetz: 'TIMETZ',
  timestamp: 'TIMESTAMP',
  timestamptz: 'TIMESTAMPTZ',
  bool: 'BOOL',
};
